# Lessons Learned

- **Sorting Mutations in Python**: Python's `.sort()` method mutates lists in place. In greedy algorithms where the original array structure should be preserved (often a requirement in real-world APIs or interview constraints), use `sorted()` and explicitly allocate `O(N)` space complexity for the sorted copy.
- **Space Complexity with Sorting Iterators**: When `sorted(...)` is used on an iterator (like `zip(...)` in Python), it consumes `O(n)` space to create the sorted list copy. Always document this `+ sorted copy` in space complexity analyses.
- **Interval Overlaps**: `>` vs `>=` is the most critical source of bugs. Always map "touching" explicitly in comments (e.g., `touching OK` -> `>=` vs `touching overlaps` -> `>`). When comparing `last` vs `current` in merge intervals, if index `i` is included in both `[a, i]` and `[i, b]`, they overlap at `i`, so use `<` or `<=` depending on inclusive vs exclusive intervals.
- **Micro-optimizations**: When optimizing hash maps to arrays for character tracking (like `last_occurrence = [0] * 26`), be mindful to emphasize the constant time lookup and space, and ensure the ord math `ord(c) - ord('a')` is consistently applied.
- **Verifying Backtracking Algorithms**: A backtracking algorithm traversing DP states (like the one in `job_scheduling_with_selection`) needs precise bounds checks to ensure elements at `i=0` are handled or evaluated correctly, and that tracking variables update without looping indefinitely. Writing quick test scripts avoids guesswork.
- **Python Zip Iterator**: Zipping two lists (`zip(A, B)`) returns an iterator. Doing `sorted(zip(A,B))` consumes it and instantiates a fully new list in memory. Memory is `O(n)` not `O(1)`.
- **Breaking Circular Dependency Constraints**: For O(n) greedy solutions over circular arrays, find the minimum (or maximum) value to "unroll" the array into a linear one by breaking the circle at the local minimum constraints. Doing this avoids O(n^2) iterate-until-convergence approaches.
- **Max-Heap Greedy Validation in Python**: In greedy algorithms delaying actions with max-heaps (e.g., Minimum Refueling Stops), verify that a premature `if not heap: return -1` check doesn't trigger when the target has already been met but the heap is incidentally empty.