# 3Sum

## Problem Statement

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

The solution set must not contain duplicate triplets.

**Example:**
```
Input: nums = [-1, 0, 1, 2, -1, -4]
Output: [[-1, -1, 2], [-1, 0, 1]]
```

## Building Intuition

### Why This Works

3Sum reduces to Two Sum by fixing one element. If we fix `nums[i]`, then we need to find two other numbers that sum to `-nums[i]`. This is exactly Two Sum with a different target.

Sorting the array first gives us two advantages. First, we can use Two Pointers (O(n) time, O(1) space) instead of a hash map for the Two Sum step. Second, we can easily skip duplicates by checking if the current element equals the previous one.

The overall structure is: for each element `nums[i]`, run Two Sum on the remaining subarray `nums[i+1:]`. Sorting costs O(n log n), and we do O(n) Two Sum passes, each taking O(n) time, for O(n^2) total.

### How to Discover This

When you see k-Sum (find k numbers summing to target), the recursive reduction is: fix one number, solve (k-1)-Sum on the rest. The base case is Two Sum, which you can solve efficiently.

Sorting is often worth the O(n log n) cost because it enables Two Pointers and simplifies duplicate handling. Ask yourself: "Would sorting help?" If yes, the extra log factor is usually acceptable.

### Pattern Recognition

This is the **Reduce to Simpler Problem** pattern combined with **Two Pointers on Sorted Array**. It appears in:
- 3Sum (this problem), 4Sum, k-Sum
- 3Sum Closest (same structure, different optimization target)
- 3Sum Smaller (counting instead of finding)
- Any problem where fixing one variable reduces to a known subproblem

## When NOT to Use

- **When you need indices, not values**: Sorting destroys original indices. You would need to store (value, original_index) pairs, adding complexity.
- **When duplicates should be kept**: This solution explicitly skips duplicates. If duplicates matter (e.g., counting triplets with multiplicity), you need a different approach.
- **When the array cannot be sorted**: If the input is a stream or sorting is forbidden, you need a hash-based approach instead of Two Pointers.
- **When k is very large in k-Sum**: The O(n^(k-1)) complexity becomes prohibitive. Consider meet-in-the-middle or other advanced techniques for large k.

## Approach

### Key Insight
Sort the array first. For each element, use Two Sum II (two pointers on sorted array) to find pairs that sum to the negative of that element.

### Algorithm
1. Sort the array
2. For each element `nums[i]`:
   - Skip if same as previous (avoid duplicate triplets)
   - Use two pointers `left = i+1`, `right = n-1`
   - Find pairs where `nums[left] + nums[right] = -nums[i]`
3. Skip duplicate values when moving pointers

```
nums = [-4, -1, -1, 0, 1, 2] (sorted)

i=0: nums[i]=-4, target=4
     left=1, right=5: -1+2=1 < 4, move left
     ...no valid pair

i=1: nums[i]=-1, target=1
     left=2, right=5: -1+2=1 ✓ → [-1,-1,2]
     left=3, right=4: 0+1=1 ✓ → [-1,0,1]

i=2: skip (same as i=1)
```

## Implementation

```python
def three_sum(nums: list[int]) -> list[list[int]]:
    """
    Find all unique triplets that sum to zero.

    Time: O(n²) - O(n log n) sort + O(n) × O(n) two pointer
    Space: O(1) or O(n) depending on sort implementation
    """
    nums.sort()
    result = []
    n = len(nums)

    for i in range(n - 2):
        # Skip duplicates for first element
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        # Early termination: if smallest element > 0, no solution
        if nums[i] > 0:
            break

        # Two pointers for remaining sum
        target = -nums[i]
        left, right = i + 1, n - 1

        while left < right:
            current_sum = nums[left] + nums[right]

            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])

                # Skip duplicates for second element
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # Skip duplicates for third element
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1

                left += 1
                right -= 1

            elif current_sum < target:
                left += 1
            else:
                right -= 1

    return result


def three_sum_closest(nums: list[int], target: int) -> int:
    """
    Find triplet sum closest to target.
    """
    nums.sort()
    n = len(nums)
    closest = float('inf')

    for i in range(n - 2):
        left, right = i + 1, n - 1

        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]

            if abs(current_sum - target) < abs(closest - target):
                closest = current_sum

            if current_sum == target:
                return target
            elif current_sum < target:
                left += 1
            else:
                right -= 1

    return closest
```

## Complexity Analysis

| Aspect | Complexity | Explanation |
|--------|------------|-------------|
| Time | O(n²) | Sorting O(n log n) + nested loops O(n²) |
| Space | O(1)* | No extra space besides output |

*Space depends on sorting algorithm used

## Edge Cases

1. **Less than 3 elements**: Return empty list
2. **All zeros**: `[0, 0, 0]` → `[[0, 0, 0]]`
3. **No valid triplets**: `[1, 2, 3]` → `[]`
4. **Many duplicates**: Handle carefully to avoid duplicate triplets
5. **All positive or all negative**: Early termination possible

## Common Mistakes

1. **Not handling duplicates**: Leads to duplicate triplets in result
2. **Off-by-one errors**: Loop should go to `n-2`, not `n-1`
3. **Not sorting first**: Two pointers require sorted array
4. **Moving wrong pointer**: After finding match, move BOTH pointers

## Variations

### 4Sum
```python
def four_sum(nums: list[int], target: int) -> list[list[int]]:
    """
    Generalize to k-sum using recursion.
    Time: O(n^(k-1)) for k-sum
    """
    def k_sum(nums: list[int], target: int, k: int) -> list[list[int]]:
        result = []

        if not nums or nums[0] * k > target or nums[-1] * k < target:
            return result

        if k == 2:
            return two_sum_sorted(nums, target)

        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            for subset in k_sum(nums[i + 1:], target - nums[i], k - 1):
                result.append([nums[i]] + subset)

        return result

    def two_sum_sorted(nums: list[int], target: int) -> list[list[int]]:
        result = []
        left, right = 0, len(nums) - 1

        while left < right:
            s = nums[left] + nums[right]
            if s == target:
                result.append([nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif s < target:
                left += 1
            else:
                right -= 1

        return result

    nums.sort()
    return k_sum(nums, target, 4)
```

### 3Sum Smaller
Count triplets with sum less than target.

```python
def three_sum_smaller(nums: list[int], target: int) -> int:
    """Count triplets with sum < target."""
    nums.sort()
    count = 0

    for i in range(len(nums) - 2):
        left, right = i + 1, len(nums) - 1

        while left < right:
            if nums[i] + nums[left] + nums[right] < target:
                # All pairs (left, left+1), (left, left+2), ..., (left, right) work
                count += right - left
                left += 1
            else:
                right -= 1

    return count
```

## Related Problems

- **Two Sum** - Foundation for this problem
- **4Sum** - Generalized to 4 numbers
- **3Sum Closest** - Find closest sum to target
- **3Sum Smaller** - Count triplets with sum < target
- **3Sum With Multiplicity** - Count with duplicates allowed
