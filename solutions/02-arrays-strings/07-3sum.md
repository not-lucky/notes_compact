# 3Sum

## Problem Statement

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

The solution set must not contain duplicate triplets.

**Example:**
```
Input: nums = [-1, 0, 1, 2, -1, -4]
Output: [[-1, -1, 2], [-1, 0, 1]]
```

## Approach

### Key Insight
Sort the array first. For each element, use Two Sum II (two pointers on sorted array) to find pairs that sum to the negative of that element.

### Algorithm
1. Sort the array
2. For each element `nums[i]`:
   - Skip if same as previous (avoid duplicate triplets)
   - Use two pointers `left = i+1`, `right = n-1`
   - Find pairs where `nums[left] + nums[right] = -nums[i]`
3. Skip duplicate values when moving pointers

```
nums = [-4, -1, -1, 0, 1, 2] (sorted)

i=0: nums[i]=-4, target=4
     left=1, right=5: -1+2=1 < 4, move left
     ...no valid pair

i=1: nums[i]=-1, target=1
     left=2, right=5: -1+2=1 ✓ → [-1,-1,2]
     left=3, right=4: 0+1=1 ✓ → [-1,0,1]

i=2: skip (same as i=1)
```

## Implementation

```python
def three_sum(nums: list[int]) -> list[list[int]]:
    """
    Find all unique triplets that sum to zero.

    Time: O(n²) - O(n log n) sort + O(n) × O(n) two pointer
    Space: O(1) or O(n) depending on sort implementation
    """
    nums.sort()
    result = []
    n = len(nums)

    for i in range(n - 2):
        # Skip duplicates for first element
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        # Early termination: if smallest element > 0, no solution
        if nums[i] > 0:
            break

        # Two pointers for remaining sum
        target = -nums[i]
        left, right = i + 1, n - 1

        while left < right:
            current_sum = nums[left] + nums[right]

            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])

                # Skip duplicates for second element
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # Skip duplicates for third element
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1

                left += 1
                right -= 1

            elif current_sum < target:
                left += 1
            else:
                right -= 1

    return result


def three_sum_closest(nums: list[int], target: int) -> int:
    """
    Find triplet sum closest to target.
    """
    nums.sort()
    n = len(nums)
    closest = float('inf')

    for i in range(n - 2):
        left, right = i + 1, n - 1

        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]

            if abs(current_sum - target) < abs(closest - target):
                closest = current_sum

            if current_sum == target:
                return target
            elif current_sum < target:
                left += 1
            else:
                right -= 1

    return closest
```

## Complexity Analysis

| Aspect | Complexity | Explanation |
|--------|------------|-------------|
| Time | O(n²) | Sorting O(n log n) + nested loops O(n²) |
| Space | O(1)* | No extra space besides output |

*Space depends on sorting algorithm used

## Edge Cases

1. **Less than 3 elements**: Return empty list
2. **All zeros**: `[0, 0, 0]` → `[[0, 0, 0]]`
3. **No valid triplets**: `[1, 2, 3]` → `[]`
4. **Many duplicates**: Handle carefully to avoid duplicate triplets
5. **All positive or all negative**: Early termination possible

## Common Mistakes

1. **Not handling duplicates**: Leads to duplicate triplets in result
2. **Off-by-one errors**: Loop should go to `n-2`, not `n-1`
3. **Not sorting first**: Two pointers require sorted array
4. **Moving wrong pointer**: After finding match, move BOTH pointers

## Variations

### 4Sum
```python
def four_sum(nums: list[int], target: int) -> list[list[int]]:
    """
    Generalize to k-sum using recursion.
    Time: O(n^(k-1)) for k-sum
    """
    def k_sum(nums: list[int], target: int, k: int) -> list[list[int]]:
        result = []

        if not nums or nums[0] * k > target or nums[-1] * k < target:
            return result

        if k == 2:
            return two_sum_sorted(nums, target)

        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            for subset in k_sum(nums[i + 1:], target - nums[i], k - 1):
                result.append([nums[i]] + subset)

        return result

    def two_sum_sorted(nums: list[int], target: int) -> list[list[int]]:
        result = []
        left, right = 0, len(nums) - 1

        while left < right:
            s = nums[left] + nums[right]
            if s == target:
                result.append([nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif s < target:
                left += 1
            else:
                right -= 1

        return result

    nums.sort()
    return k_sum(nums, target, 4)
```

### 3Sum Smaller
Count triplets with sum less than target.

```python
def three_sum_smaller(nums: list[int], target: int) -> int:
    """Count triplets with sum < target."""
    nums.sort()
    count = 0

    for i in range(len(nums) - 2):
        left, right = i + 1, len(nums) - 1

        while left < right:
            if nums[i] + nums[left] + nums[right] < target:
                # All pairs (left, left+1), (left, left+2), ..., (left, right) work
                count += right - left
                left += 1
            else:
                right -= 1

    return count
```

## Related Problems

- **Two Sum** - Foundation for this problem
- **4Sum** - Generalized to 4 numbers
- **3Sum Closest** - Find closest sum to target
- **3Sum Smaller** - Count triplets with sum < target
- **3Sum With Multiplicity** - Count with duplicates allowed
